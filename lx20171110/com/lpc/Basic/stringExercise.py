'''
name = 'string'

print('aaa\tbbbb\vcccc\rdddd\neeee\'\\')  # 注释符号分别是：横向制表符 ， 纵向制表符 ，回车， 换行，转义，一般来说后面换行和转义字符比较常用
aaa='11111'
print('hello,%s'%'world','1111',aaa)  # 居然支持这种形式,首先是可以多个字段用逗号隔开的输出，其他如果使用%连接就可以和前面对应起来
print ("hello %s，my name is lpc"%"xiaoding") # 虽然不写里面的%s也不会编译错误，但是会导致运行错误，语法是%左侧是待格式化的字符串，右侧是希望格式化的值，值可以是数字或者字符串
print("I am %.2f years old" % 10.5) # 默认为6位小数，制定后就可以了，不加.2直接写2没有任何作用，直接忽略
print ("今年的比例是%.2f"%2.333+"%")
print ("今年的比例是%.2f%%"%2.333)  # 如果将% 更换为，就会原样输出 %.2f%% 2.333,这样可以理解为，这个只是简单的拼接起来了，和+类似了
print ("今年的比例是%.2f,增长数是%d",(3.33,333))
print ("今年是%s年，中国女排夺得本届奥运会%s,中国共获得%d枚金牌"%('2018','冠军',30))
'''
# 20180104

# print('''
# 指定总长度为5个%5f,不知道为何指定长度没有效果
# 指定小数位数为2%.2f,没有的时候会使用0进行填充
# 指定小数总长度为5，小数位数为2位%5.2f，
# 截取字符串指定位数%.2s，
# 元组中的字符长度和小数位数分别是%*.*s,不是开始理解的那样，而是将后面的字符串处理为指定的长度和精度，精度使用空格填充在前面，主要的作用在于动态指定截取的位数
# '''
# % (123456789, 2323, 123456789.1234, 'wahaha', 10, 5, 'wahahaha'))  # 从结果看小数点也是计算在总位数内的

'''
str='字符查找从0开始计算序号，aaa找到返回第一个位置的序号，指定的结束位置超过字符串长度不会报错，aaa找不到返回-1'
print(str.find('aaa',2,123))
lb=['>>>join','>>>用于将拼接成新的字符串','>>>当两个字符串都很长的时候，我们可以看到这个顺序是不受控制的，要注意使用']
print(str.join(lb)) # 只能拼接字符串，其他的会报错

str1='AAAaaa有中文在还是不影响转换结果'
print('全部转为小写',str1.lower(),'全部转为大写',str1.upper())   # 英文处理还是可以的，有中文不影响转换

# str2 = 'AAAaaa大小写互换'
# print('大小写互换之后：'+str2.swapcase())
# 
print(str2.replace('大小写互换','替换指定字符串',3))  # 没什么特别要说的，主要是这里有个替换次数的参数
str2=str2.join('aaa123')  # 可以看到拼接时是将字符串当作元组进行拆分挨个进行拼接之后的结果
print(str2,'>>>>',str2.split('aaa',2)) # 使用aaa作为分隔符，分割2次，当然两个参数都不是必须的，默认就是全部按照空格进行分割

str2 = 'AAAaaa大小写互换'
str2=str2.join(('---','---'))  # 拼接并未改变字符串本身，所以需要重新接收下
print(str2,"\n去除字符串两头的指定字符之后：",str2.strip('---'))  # 没有这个字符不会报错
'''
#### 加密和翻译使用的替换方式 translate比repalce的好处在于可以同事替换多个替换
# intab = 'abcdefg'
# outtab = '1234567'
# jmzf = "dfasdffa23rdjfao423"
# transtab = jmzf.maketrans(intab,outtab)  # 获取翻译对应表
# jmh2 = jmzf.translate(transtab) # 使用表进行翻译
# print(jmzf,'获取到的表是：',transtab,'翻译结果为：',jmh2)
#
# print("圆周率在字符长度前面加0后的结果：%06.2f"%3.1415926)  # 指定之后使用0填充
# print("圆周率在字符精度前面加0后的结果：%6.02f"%3.1415926)  # 没有指定填充为空格填充
# print("圆周率在字符长度前面加0后的结果：%16.2f"%3.1415926)  # 大于0时会被当作指定长度来处理，精度后的道理一样，如果大于0则会认为是这么多精度
# 练习题
num = (132-100)*100/100
print("练习题目结果：%.2f"% num,'%')  # 将上面的结果直接放在这里输出会提示字符串不是支持的类型，这个应该和默认类型有关系




